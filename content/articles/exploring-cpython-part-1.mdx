---
title: Exploring CPython (Part 1)
description: In this article we will explore how CPython works under the hood.
date: 2025-10-27
tags:
  - cpython
  - python
  - under the hood
---

<script lang="ts">
	import ContentInformation from '$components/Content/ContentInformation.svelte'; import
	ContentExcalidraw from '$components/Content/ContentExcalidraw.svelte'; import ContentTabs from
	'$components/Content/ContentTabs.svelte'; import ContentTab from
	'$components/Content/ContentTab.svelte';
</script>

<ContentInformation title="Info">
	All of the following information is current as of Python version 3.15 - latest version at the time
	of writing.
</ContentInformation>

# Introduction

Hello! Currently I'm working on a big ptoject - Python interpreter. Before this,
I need to investigate about how CPython - reference Python implementation - works.
This article will tell you about this.

# First steps

Firstly, we need to clone repo and build it.

```bash
git clone https://github.com/python/cpython.git --depth=1
cd cpython
# As I'm on Windows, I run this command
PCbuild\build.bat -c Debug
```

[See official documentation](https://devguide.python.org/getting-started/setup-building) for more details on setting it up.

# Theory

## Compilers and interpreters

<ContentTabs class="my-6">

    <ContentTab title="Compiler">

        - Compiles code to machine code
        - Usually faster
        - Optimises better
        - Needs time to compile

</ContentTab>

    <ContentTab title="Tree-walk interpreter">

        - Reads and runs code line-wise
        - Fast development
        - Errors are only show at runtime
        - Slow

</ContentTab>

    <ContentTab title="Bytecode interpreter">

        - Compiles program to bytecode and then runs it on VM
        - Faster
        - Needs more resources

</ContentTab>

</ContentTabs>

Python is **bytecode interpreter**.

## VMs

_VM_ stands for virtual machine. There are _register_ and _stack_ VMs. Python
is **stack VM**.

# Stages of interpretation

There are few stages of interpretation. Here's some info about them.

## Tokenization

In this stage interpreter translates code string to _token stream_. You can
experiment with it via `tokenize` module. For example, this code:

```python
from tokenize import tokenize
from io import BytesIO
from token import tok_name

code_string = 'print(2 * 5)'

tokens = tokenize(BytesIO(code_string.encode('utf-8')).readline)

for token in tokens:
    print(f"{token.string} {tok_name[token.type]}")
```

will print following:

```text
utf-8 ENCODING
print NAME
( OP
2 NUMBER
* OP
5 NUMBER
) OP
 NEWLINE
 ENDMARKER
```

Here, value in first column (e.g. `(` or `print`) is _token_ and second value is _token name_ (first line is just encoding).

## Parsing

While next stage, parsing, tokens are translated into <abbr title="Abstract Syntax Tree">AST</abbr>. For example, following code:

```python
import ast

obj = ast.parse("def sum(a: int, b: int) -> int: return a * b")

print(ast.dump(obj))
```

will print AST of `def sum(a: int, b: int) -> int: return a * b`:

```text
Module(body=[FunctionDef(name='sum', args=arguments(posonlyargs=[], args=[arg(arg='a', annotation=Name(id='int', ctx=Load())), arg(arg='b', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(value=BinOp(left=Name(id='a', ctx=Load()), op=Mult(), right=Name(id='b', ctx=Load())))], decorator_list=[], returns=Name(id='int', ctx=Load()), type_params=[])], type_ignores=[])
```

or, in more readable form:

```text
Module(
    body=[
        FunctionDef(
            name='sum',
            args=arguments(
                posonlyargs=[],
                args=[
                    arg(arg='a', annotation=Name(id='int', ctx=Load())),
                    arg(arg='b', annotation=Name(id='int', ctx=Load()))
                ],
                kwonlyargs=[],
                kw_defaults=[],
                defaults=[]
            ),
            body=[
                Return(
                    value=BinOp(
                        left=Name(id='a', ctx=Load()),
                        op=Mult(),
                        right=Name(id='b', ctx=Load())
                    )
                )
            ],
            decorator_list=[],
            returns=Name(id='int', ctx=Load()),
            type_params=[]
        )
    ],
    type_ignores=[]
)
```

As you may see, AST builds from _nodes_, e.g. `Module` or `BinOp`.

## Transforming AST to bytecode

The next stage is _transforming AST to bytecode_. It's very similiar to
compilation, but in our case it transforms to bytecode instead of machine code.
For example, following code:

```python
from dis import dis

sum = lambda a, b: a + b

dis(sum)
```

will print bytecode of `sum` lambda:

```text
3           0 RESUME                   0
            2 LOAD_FAST                0 (a)
            4 LOAD_FAST                1 (b)
            6 BINARY_OP                0 (+)
           10 RETURN_VALUE
```

Fisrt column stands for line number. Second column is _byte offset within
function's bytecode sequence_ or _instruction address_. Third one is opcode
name - the actual operation interpreter will perform. Fourth one is argument for
opcode. And fifth one is that argument in human-readable form/

# Typical CPython source code layout

Okay, we've learned some theory about compilation. It's time to actually read
code! In this diagram you can see, where things are _typically_ located:

<ContentExcalidraw src="/articles/exploring-cpython-part-1/source-code-layout.svg" />

<ContentInformation title="Glossary">

    **Module** - an object that serves as an organizational unit of Python code. Modules have a namespace containing arbitrary Python objects. Modules are loaded into Python by the process of importing.<br>
    **Extension module** - a module written in C or C++, using Pythonâ€™s C API to interact with the core and with user code.<br>
    **Built-in functions and modules** - functions and modules, built into intepreter.<br>
    [\<Source\>](https://docs.python.org/3/glossary.html)

</ContentInformation>

But there are some exceptions, for example:

- Built-in type `int` is at `Objects/longobject.c`
- Built-in type `str` is at `Objects/unicodeobject.c`
- Built-in module `sys` is at `Python/sysmodule.c`
- Built-in module `marshal` is at `Python/marshal.c`
- Windows-only module `winreg` is at `PC/winreg.c`

---

_to be continued_

---

I hope this article was useful for you. Found mistake, typo or have feedback?
Feel free to open issue/PR in [website repo](https://github.com/ankddev/website).
